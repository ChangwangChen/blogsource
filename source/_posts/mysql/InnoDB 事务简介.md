---
title: InnoDB 锁总结
date: 2020-08-22 13:50:45
categories: MySQL
tags: [MySQL]
---

### ACID 特性

- Atomicity： 原子性

每个事务中的所有操作， 要么全部成功， 要么全部失败，不会存在中间状态

- Consistency： 一致性

事务是将数据库从一个一致的状态转到了另一个一致的状态。 在事务开始之前和结束之后， 数据库的完整性约束不会遭到破坏。

- Isolation： 隔离性

隔离性要求每个读写事务的对象对其他事务的操作对象能够相互分离， 即该事务在提交之前对其他事务都不可见。

- Durability： 持久性

 事务一旦被提交，其结果就是永久性的， 即使发生宕机事故， 数据库也要能够将数据恢复。

### 事务的实现

事务的隔离性由锁来实现。 事务的原子性和持久性由 redo log 来保证， 事务的一致性由 undo log 来保证。

undo log 和 redo log 的作用都是一种恢复操作。 redo 恢复提交事务修改的页的操作， undo 回滚行记录到某个特定版本。所以， redo 通常是物理日志， 记录的是页的物理修改操作。 undo 是逻辑日志， 根据每行记录进行记录。

```
Double Write： 两次写机制， InnoDB在刷新内存中的脏页的时候使用的技术， 为了保证磁盘数据页的可靠性。

此机制有两个部分组成， 内存中的 2MB 的 Double Write Buffer；磁盘上面共享表空间中的连续 128 个页 （128 × 16KB = 2MB）。

实现过程：

1. 首先将内存中需刷新的脏页数据复制到内存中的 Double Write Buffer 中
2. 将内存中 Double Write Buffer 中的数据分 2 次分别顺序的写入到磁盘共享表空间中， 每次写完之后马上调用 fsync， 保证数据落盘。 此次写入磁盘是顺序写入， 需要时间较短。
3. 在将内存中的 Double Write Buffer 中的脏页数据分别写入到数据库对应的页中， 此次写入磁盘是离散的， 需要的时间较长

```

#### redo 

redo log 由 2 部分组成： 内存中的 redo log buffer； 磁盘中的 redo log file。

InnoDB 引擎通过 `Force Log at Commit` 机制实现事务的持久性。 即当事务提交的时候， 必须先将该事务的所有日志写入到`重做日志`进行持久化，然后待事务的操作完成才算完成。这里的重做日志包括： redo log 和 undo log。 redo log 保证了事务的持久性， undo log 来帮助事务回滚和 MVCC 功能。

redo log 是顺序写的操作， 因为不会对已经写入的 redo log 进行读取；undo log 是需要进行随机读写的。 每次将重做日志缓冲写入文件的时候， 需要调用 fsync 进行刷盘。所以， 磁盘的性能直接影响数据库事务提交的性能。

重做日志是以 512 字节进行存储， 被称做 重做日志块（redo log block）。由于
磁盘的扇区大小也是 512 字节， 所以重做日志的写入可以保证原子性， 不需要 `Doublw Write`。


#### undo

undo 是为了保证事务的一致性， 给事务提供了回滚的功能。 undo 存放在数据库内部的一个特殊的段中， 称作 undo 段（undo segment）。undo 段位于共享表空间内。

undo log 是逻辑日志， 因此回滚也是将数据库逻辑的回滚到事务开启之前的样子。事物中的每个 DELETE 会在回滚时转换成 INSERT， 每个 INSERT 转换成 DELETE， 每个 UPDATE 也会转换成与之相反的 UPDATE。

undo 的另一个作用是实现 MVCC， 当用户读取一行记录的时候， 若记录已经被其他事务占用， 当前的事务可以通过 undo 读取之前的行版本信息， 实现非锁定读取。

undo log 的产生会产生 redo log， 也就是说 undo log 的产生也会伴随着 redo log 的产生， 因为 undo log 也需要持久性保护。


#### purge

InnoDB 中的 DELETE 和 UPDATE 操作并没有直接的删除或者更新数据， 而是在指定的数据上面加上 flag， 最终的修改有 purge 完成。


### 隔离级别

#### READ UNCOMMITTED

读未提交，也被称之为浏览访问（Browse access）。指在事务中可以读取到另一事务还没有提交的修改。这时会出现脏读和幻读的问题。

#### READ COMMITTED

读已提交， 也被称之为游标稳定（cursor stability）。 指在事务中可以读取到另外事务已经提交的记录。 此隔离级别解决了脏读的问题， 但是并没有解决幻读的问题。

#### REPEATABLE READ

InnoDB 引擎的默认隔离级别是可重复读， 并且使用了 Next-Key Lock 算法避免了幻读的产生。因此， 在此隔离级别下， 已经达到了串行化的要求。

#### SERIALIZABLE

串行化， SQL 和 SQL2 标准的默认隔离级别。InnoDB 在此隔离级别下， 会在每个 SELECT 语句后加上 LOCK IN SHARE MODE， 即为每个读取操作都加上一个共享锁。因此， 此隔离级别下， 不再支持一致性的非锁定读。

InnoDB 的本地事务一般使用 REPEATABLE READ 隔离级别， 在分布式的事务场景中， 使用 SERIALIABLE 隔离级别。

### 分布式事务

InnoDB 引擎提供了对 XA 事务的支持， 并通过 XA 事务来支持分布式事务的实现。使用分布式事务时， InnoDB 引擎的事务隔离级别必须是 SERIALIZABLE （串行化）。

XA 事务有一个或者多个资源管理器（Resource Managers）、一个事务管理器（Transaction Manager） 和一个应用程序（Application Program）组成。

- `资源管理器`： 提供访问事务资源的方法。 通常一个数据库就是一个资源管理器。
- `事务管理器`： 协调参与全局事务中的各个事务。需要与参与全局事务的所有资源管理器进行通讯。
- `应用程序`： 定义事务的边界， 指定全局事务中的操作。


分布式事务使用了`两阶段提交`（two-phase commit）的方式。第一阶段： 所有参与全局事务的节点都开始准备（PREPARE）， 并告诉事务管理器他们都准备好了。第二阶段： 事务管理器告诉资源管理器执行 ROLLBACK 还是 COMMIT。如果任一节点显示不能提交， 所有的节点都被告知需要回滚。

#### 内部 XA 事务

在同一个 MySQL 实例中， 有时也需要使用分布式事务。例如， binlog 和 InnoDB 引擎之间。开启了复制功能的数据库都会记录 binlong， 在事务提交的时候， 先写二进制日志， 再写 InnoDB 存储引擎的重做日志， 上述的两个操作的要求也是原子的， 要么都成功， 要么都失败。

当事务提交的时候， InnoDB 存储引擎先做一个 PREPARE 的操作， 将事务的 xid 写入， 接着进行二进制文件的写入。


```
MySQL 复制的内容比较简单， 不再另开文章介绍， 直接卸载这里。
```
### 复制

复制（Replication） 是 MySQL 高可用的解决方案。实现原理如下所示：

1. 主服务器（Master）把数据的更改记录到二进制文件（binlog）中
2. 从服务器（Slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中
3. 从服务器重做中继日志中的日志信息（回放）， 把更改应用到自己的数据库上， 达到数据的最终一致性

复制可以用来实现备份， 但是功能不仅仅局限于备份。 其主要功能如下：
- 数据分布。 由于MySQL数据库的复制并不需要很大的带宽要求， 因此可以在不同的数据中心之间实现数据的复制
- 读取的负载均衡。 建立多个从数据库， 可以将大量的读取操作分布到这些从服务器中， 减少主服务器的压力。 一般通过 DNS 轮询（Round-Robin） 和 Linux 的 LVS 实现负载均衡。也可以使用连接池在客户端实现负载均衡。
- 备份。复制对备份很有帮助， 但是从服务器不是备份， 不能完全替代备份。
- 高可用和故障转移。 复制建立的从服务器有助于故障转移， 减少故障的停机时间和回复时间。

#### 二进制日志（binlog）

二进制文件（binary log） 记录了对 MySQl 数据库执行更改的所有操作（即使操作没有对数据库进行更改）， 不包括 SELECT 和 SHOW 操作。此文件是数据库级别实现的， 所有的存储引擎都能够使用。

二进制文件的作用：
- 恢复（Recovery）： 某些数据库的恢复需要二进制文件， 例如，在一个数据库全量文件恢复后， 用户可以通过二进制文件进行 point-in-time 的恢复。
- 复制（Replication）：参见上节。
- 审计（Aduit）： 用户可以通过二进制日志中的信息来进行审计， 判断是否有对数据库进行注入的攻击。

二进制日志的格式：
- STATEMENT： 二进制文件记录的是逻辑 SQL 语句。
- ROW： 二进制文件记录表中行的修改情况。

如果设置了 binlog_format 为 ROW， 可以将 InnoDB 的事务隔离级别设置为 READ COMMITTED， 获得更好的并发性。

推荐使用 ROW 格式的我二进制日志。

- MIXED： 此格式下， MySQL 默认采取 STATEMENT 的格式进行二进制文件的记录。 在一些情况下会使用 ROW 格式。

可能的情况：
1. 表的存储引擎为 NDB， 这时表的 DML 操作都会以 ROW 的格式记录
2. 使用了 UUID(), USER(), CURRENT_USER(), FOUND_ROWS(), ROW_COUNT() 等不确定函数
3. 使用了 INSERT DELAY 语句
4. 使用了用户定义函数（User Defined Function）
5. 使用了临时表（Temporary Table）



