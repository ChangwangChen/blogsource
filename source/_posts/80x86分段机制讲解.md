---
title: 80x86分段机制讲解
date: 2017-09-06 11:30:30
categories: Linux
tags: [Linux]
---

# 前言

这是一篇作者自己关于`<<深入理解Linux内核>>`一书中内存管理章节的读后总结, 主要是关于`80x86`架构处理器对于保护模式下, `硬件分段管理`的说明.

<!--more-->

# 概述

这边文章的只关注于`80x86保护模式下内存分段机制的讲解`,是作者在阅读`<<深入理解Linux内核>>`第二章内存寻址部分中硬件分段章节的总结.

文章内容比较简短, 类似读书笔记.想要查看详尽的讲解, 请移步到[Linux内存寻址之分段机制](/2017/08/15/Linux内存寻址之分段机制)和[Linux内存寻址之分页机制](/2017/08/15/Linux内存寻址之分页机制).

# 正文

## 内存地址

在使用`80X86微处理器`的时候, 访问系统中的内存空间存在3中地址: 逻辑地址, 线性地址和物理地址.

`逻辑地址`:
机器语言指令仍用这种地址指定一个操作数的地址或一条指令的地址。 这种寻址方式在Intel的分段结构中表现得尤为具体，它使得MS-DOS或Windows程序员把程序分为若干段。每个逻辑地址都由一个段和偏移量组成。
`线性地址`：
线性地址是一个32位的无符号整数，可以表达高达232（4GB）的地址。通常用16进制表示线性地址，其取值范围为0x00000000～0xffffffff。
`物理地址`：
也就是内存单元的实际地址，用于芯片级内存单元寻址。 物理地址也由32位无符号整数表示。

```
在本文讲述中, `逻辑地址`为48位, 其中`段选择符`为16位, `偏移量`为32位;而且文章只讲述怎样将 48 位的逻辑地址转换成线性地址.

并且这些转换是有硬件直接支持, 即 MMU.
```

## 段选择符和段描述符

`逻辑地址`由`段选择符`和`偏移地址`共同组成, 其中`段选择符`的作用就是通过其来获取`段描述符`. 所有系统的段描述符都保存在`全局段描述符表(GDT)`中.下面我们先来看看`段选择符`.

### 段选择符

![段选择符](/images/selector.jpg)

```
`段选择符`一共16位. 

最后一位`RPL`表示请求特级, 0 为最高优先级, 3 代表最低优先级(Linux只是用这两个值).

`TI`的值表示需要从哪个描述符表中去寻找`段描述符`.其中, `TI`为 0 从`全局段描述符表`, `TI`为 1 从`局部段描述符表`. 

剩下的 13 位为`index`, 用于寻找段描述符的入口, 所以可以看出, 段描述符的总数为 2^13 = 8192.

GDT的第一项总是设置为0, 这样GDT中保存的段描述符总数为 2^13 - 1 = 8191. 这样设置的好处是空的段选择符的逻辑地址会被认为是无效的, 并且会引起一个`处理器异常`.
```

### 段描述符

![段描述符](/images/descriptor.jpg)

关于段描述符, 我们需要了解以下几点:

- `BASE字段(32位)`用于计算最终的线性地址.
- `GDT(LDT)`的`起始地址`和`大小`存放在`gdtr(ldtr)`中, 方便程序寻找`段描述符`
- `段描述符`一共64位(`8个字节`), 所以当使用段选择符寻找来寻找的时候, 需要将`段选择符的index字段`的值乘以8, 并且和`gdtr(ldtr)`中存储的`gdt(ldt)起始地址`相加,得出`段描述符`的地址, 从而获取`段描述符`
- 上述寻找`段描述符`的过程只有的`段寄存器`中存储的值发生改变的时候才会执行, 每当一个段选择符装入段寄存器的时候, 系统将会把与之相应的段描述符装入到对应的`非编程CPU寄存器`中, CPU直接读取寄存器中的值来获取段描述符.

## 地址转换(逻辑地址到线性地址)

![地址转换](/images/exchange.jpg)

上图展示了MMU中的`分段单元(segmentation unit)`将逻辑地址转换成线性地址的过程. 有了前面部分的讲解, 这张图的过程就很好理解了.


我们还是在罗嗦几点[:)]:

- `逻辑地址(48位)`由`段选择符(16位)`和`偏离量OFFSET(32位)`组成
- `段选择符`中的`Index字段`是`13`位
- `gdtr(ldtr)`中存储了`段描述符表`这个数据结构的起始地址和大小
- 通过`段选择符Index字段`计算段描述符的时候, 需要 `x8(乘8倍)`, 因为段描述符占用`8个字节`
- 计算最终的线性地址的时候, 使用的是`段描述符中的BASE字段(32位)`和`逻辑地址的OFFSET字段(32位)`相加得出

## 参考

`<<深入理解Linux内核>>`

